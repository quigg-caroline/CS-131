Approach & Thinking

Warm Up: This first problem helped me build the intutition needed to complete the parse_prefix function. The way this problem works is it uses function currying to help transform HW1 grammar to HW2 grammar. This is done by having an outside function called "test", this function will iterate through the list of (nonterm,rule_list) tuples from the HW1 style and for every tuple with a lhs matching the desired lhs , it will produce a list of rules that match with that nonterminal. This function accepts two parameters (lhs and rules). Rules is filled by (snd gram) and the lhs param is left blank, therefore creating the grammar rule pattern consistent with HW2 style.

Parse Prefix: This problem was very challenging for me and took a lot of thinking to understand. I realized that this problem would use a lot of recursion and that the notion of backtracking and bubbling-up would be crucial to my parser working. In my first attempt I tried to define distinct functions that would be used in the recursion, sort of a group of functions that went from the top level to the lower level of the parsing. However I found that when matching specific symbols, it was necessary to then return to a higher level to continue parsing. So I had a problem of two recursive functions, each calling one another. So I was able to tweak my design and define three functions together and accomplish the type of recursion I was hoping for. 

The biggest struggle I had was effectively capturing the backtracking for rules when it was necessary to do a lot of derivations for the prefix of a certain rule. I kept finding that a certain derivation would end up being done twice (e.g. [3; + ; $ ; 4]) would derive 3 and then use L value -> T $, N Num to derive 4, but then it would also derive 4 again from the top level. I could not find a good way to backtrace. 

It took a while but I finally realized that while derived one side of a rule, I could save the other part of the rule in the acceptor funtion passed around my program, this could be accomplished by using my function which derives rules as an acceptor function (see line 30 of my code)

Organization:

deriv_pref: This function is responsible for taking a list of rules associated with a nonterminal symbol and then will attempt to match these rules to the given fragment. If a rule is not matched, it will proceed to the next rule in the list of alternative rules.

match_rule: This function is responsible for taking a rule and seeing if it is an accepted match for the given code fragment. The code will first check to see if the provided rule is empty, in this case it will check if the current derivation and fragment are acceptable. If there is still part of the rule to be parsed, and there is still part of the fragment to be parsed, then it will call a function to match the first symbol in the rule with the first symbol in the fragment.

match_term: This function is responsible for taking a rule and fragment and comparing the heads of each, if the head of the rule is a terminal symbol which matchs with the head of the fragment, then the remainder of the rule and list are passed back up to match_rule, else if it is terminal and doesnt match we know this rule will not match. If the head of the rule is nonterminal it will pass up the nonterminal to the deriv_pref function, in order to try and further parse the nonterminal and derive it. The key part of this step, is the acceptor function passed to deriv_pref is a partial match_rule containing the remainder of the current rule in its parameters. This ensures that when we are finished parsing and deriving the nonterminal we passed back up to deriv_perf, we will resume parsing and derivation of the remainder of our rule.